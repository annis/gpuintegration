---
title: "Genz function 1 absolute value in 5d"
author: "Marc Paterno"
date: "6/9/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

## Purpose of this document

This document shows a performance comparison between the serial
and parallel implementations of the CUHRE algorithm for a
positive-definite integrand.

The integrand chosen is:
$$ | \cos(4 v +5 w + 6 x +7 y + 8 z)/k |$$
with $k = 0.6371054$. For this integrand, the normalization is approximate (meaning that the true value of the integrand is close to,
but not exactly, 1.0).

## Testing environment

These tests were run on `ibmpower9.fnal.gov`.

```{r child = 'power9_description.Rmd'}
```

## Description of the dataframe

```{r child = 'dataframe-description.Rmd'}
```

```{r read_data, echo = FALSE, message = FALSE}
d <- bind_rows(read_tsv("genz_1abs_5d.out"),
               read_tsv("cuda_genz_1abs_5d.out")) %>%
  mutate(r = errorest/(epsrel*value),
         converged = (r < 1.0)) %>%
  arrange(alg, desc(epsrel))

knitr::kable(d, digits = 30)
```

## Analysis

The parallel algorithm (at least as I have used it) seems not to be influenced by the user-specified fractional error target.
The plot (and especially the fit) is not at all currently meaningful.

Because the range of fractional error tolerance values is large, and the range of times is very large,
we use log scales for our plot.
The line is a fitted linear model; the fit is clearly poor.

```{r, echo = FALSE, message = FALSE}
ggplot(d, aes(1/epsrel, time, color = converged)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  facet_wrap(vars(alg), scales = "free")
```

The number of regions needed to obtain a given fractional error tolerance seems to be related in a power law
to the reciprocal of the fractional error tolerance, for the serial algorithm.
Because the parallel algorithm is not yet working correctly, that plot is currently uninformative.
The shaded band indicates the linear model's standard error estimate.

```{r, echo = FALSE}
ggplot(d, aes(1/epsrel, nregions, color = converged)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  facet_wrap(vars(alg), scales = "free")
```

Does the estimated *value* of the integral show any trend as we tighten the required fractional
error tolerance?

```{r, echo = FALSE}
ggplot(d, aes(1/epsrel, value, color = converged)) +
  geom_point() +
  scale_x_log10() +
  facet_wrap(vars(alg), scales = "free")
```

