library(tidyverse)
#library(ldrd2020050)
#library(xtable)
library(cowplot)

# Utility functions

read_csv <- function(filename){
  df <- read.csv(file = paste(filename,".csv", sep=""), 
                 header = TRUE, 
                 sep=",",row.names=NULL)
}

# from a .csv file containing the following
# id, heuristicID, value, epsrel, epsabs, estimate, errorest, regions, fregions, status, final, lastPhase, total_time 
# or
# id, value, epsrel, epsabs, estimate, errorest, regions, status, final, total_time

# id: integrand identifier
# heuristicID, a value of "no load-balancing" indicates that no relative-error filtering is to occur, "zero" indicates default behavior
# epsrel: user-specified relative error tolerance: i.e. 1e-3
# epsabs: absolute error tolerance
# estimate: the program's resulting computation for the integral value
# errorest: the program's resulting computation for error margin of its computation on the integral value
# regions: the number of leaf regions (finished+active) at the time of termination
# fregions: the number of finished regions at the time of termination
# status: 0 for successful integration, 1 for not reaching user's accuracy
# final: value of 1, flag indicating whether only the leaf regions where used to compute the errorest and estimate, 0 for using all results from previous iterations
# lastPhase: 1,2 indicating the last phase executed, only applicable on parallel methods
# total_time: execution time in milliseconds of integration routine

convert_to_cuhre_format <- function(df, hardware){
  df <- mutate(df,  
               error            = abs(value-estimate),
               relative_error   = abs(error/value),
               ratio            = abs(errorest/(estimate*epsrel)),
               err_ratio        = error/errorest,
               prec             = log10(1/epsrel),
               symbol            = 16/(as.integer(status)+1),
               hw              =  hardware)
}

PrintPDF <- function(plot, filename){
  pdf(filename)
  print(plot)
  dev.off()
}

#given two dataframes generated by convert_to_cuhre_format, and a list of integrand string ids, gerate speedup plots

plotSpeedup <- function(df){
  ggplot(data = df) + 
    geom_point(mapping = aes(prec, speedup, color = id, shape = as.integer(status+16)), size = dotSize) +
    geom_line(mapping = aes(prec, speedup, color = id)) +
    xlab("User-specified digits of precision") + 
    ylab("Speedup") + 
    scale_y_continuous(trans = "log10") +
    facet_wrap(vars(slabel))+
    theme_bw()+
    scale_shape_identity()+
    theme(aspect.ratio = 1,
          legend.position='bottom' )
}

groupPlotSpeedup <- function(df1, df2, idsToBeCompared, label){
  speedup_df <- df1[1,] %>% select(id, total_time, prec, epsrel, status) 
  speedup_df <- mutate(speedup_df, speedup=0)
  speedup_df[1,1] <- "placeholder"
  
  for(ID in ids){
    temp_df1    <-  filter(df1, id == ID) %>% select(id, total_time, prec, epsrel, status)
    temp_df2    <-  filter(df2, id == ID ) %>% select(id, total_time, prec, epsrel, status) 
    
    numComparable <- min(nrow(temp_df1), nrow(temp_df2))
    
    #filter out entries if not both dfs have it, assumes common starting epsrel/prec
    temp_df1      <-  temp_df1[1:numComparable,]
    temp_df2       <- temp_df2[1:numComparable,]
    
    temp_df1     <- mutate(temp_df1, speedup = temp_df1$total_time/temp_df2$total_time)
    temp_df1 <- mutate(temp_df1, status = temp_df2$status - temp_df1$status)
    speedup_df <- rbind(speedup_df, temp_df1)
    speedup_df <- filter(speedup_df, id != "placeholder")
  }
  speedup_df <- mutate(speedup_df, slabel = label)
  filter(speedup_df, id != "placeholder")
}

#used by ggplot's geom_point in the rest of the script
dotSize <- 2


twoPhase <- read_csv(file = "twoPhase")
BFCMemExhaustion <- read_csv(file = "BFCMemExhaustion")
BFCNoFiltering  <- read_csv(file = "BFCNoFiltering")
BFC <- read_csv(file = "BFC")
dc <- read_csv(file = "seqCuhre") 
dc <- mutate(dc, fregions = 0, lastPhase = 0)

BFC    <- convert_to_cuhre_format(filter(BFC, status == 0), "PAGANI")
twoPhase <- convert_to_cuhre_format(filter(twoPhase, status == 0), "two-phase cuhre")
dc      <- convert_to_cuhre_format(filter(dc, status == 0), "cuhre")
BFCMemExhaustion       <- convert_to_cuhre_format(filter(BFCMemExhaustion, status == 0), "Mem-exhaustion")
BFCNoFiltering       <- convert_to_cuhre_format(filter(BFCNoFiltering, status == 0), "No filtering")

temp <- rbind(select(BFCNoFiltering, id, prec, hw, error, relative_error, epsrel, total_time, regions, fregions, lastPhase, estimate, errorest, status),
              select(BFCMemExhaustion, id, prec, hw, error, relative_error, epsrel, total_time, regions, fregions, lastPhase, estimate, errorest, status),
              select(BFC, id, prec, hw, error, relative_error, epsrel, total_time, regions, fregions, lastPhase, estimate, errorest, status),
              select(twoPhase, id, prec, hw, error, relative_error, epsrel, total_time, regions, fregions, lastPhase, estimate, errorest, status),
              select(dc, id, prec, hw, error, relative_error, epsrel, total_time, regions, fregions, lastPhase, estimate, errorest, status))

temp <- mutate(temp, algorithm=hw)
temp <- mutate(temp, filtering=hw)
ids <- unique(temp$id)


df <- filter(temp, (algorithm == 'two-phase cuhre' | algorithm == 'PAGANI') & (id == '8D f7' | id == '5D f4' | id == '6D f6'))
pdcAccuracy <- ggplot(data = df) + 
  geom_line(mapping = aes(prec, relative_error, color = algorithm)) +
  geom_point(mapping = aes(prec, relative_error, color = algorithm, shape=algorithm), size = dotSize) +
  geom_line(mapping = aes(x= prec, y = epsrel), color = "black", linetype = "dashed") +
  scale_y_continuous(trans = "log10") +
  xlab("User-specified digits of precision") + 
  ylab("True relative error") + 
  facet_wrap(vars(id))+
  theme_bw()+
  theme(aspect.ratio = 1,
        legend.position='bottom') #, legend.margin=margin(0,0,0,0), legend.box.margin=margin(-10,-10,-10,-10))
print(pdcAccuracy)
PrintPDF(pdcAccuracy, "pdcAccuracy.pdf")

df <- filter(temp, 
             (filtering == 'No filtering' | filtering == 'Mem-exhaustion' | filtering == 'PAGANI') & 
               (id == "5D f4" | id == "8D f5" | id == "8D f4"))

maxMemVsCPUCache <- ggplot(data = df) + 
  geom_line(mapping = aes(prec, total_time, color = filtering)) +
  geom_point(mapping = aes(prec, total_time, color = filtering, shape = filtering), size = dotSize) +
  scale_y_continuous(trans = "log10") +
  xlab("User-specified digits of precision") + 
  ylab("Time (ms)") + 
  facet_wrap(vars(id), 
             scales = "free") + 
  theme_bw()+
  theme(aspect.ratio = 1,
        legend.position='bottom' )
PrintPDF(maxMemVsCPUCache, "FilteringsComp.pdf")
print(maxMemVsCPUCache)


FinalTimeComparisons <- ggplot(data = filter(temp, (algorithm == 'PAGANI' | algorithm == 'two-phase cuhre' | algorithm == 'cuhre') & 
                                               (id == '8D f7' | id == '5D f4' | id == '6D f6'))) + 
  geom_line(mapping = aes(prec, total_time, color = algorithm)) +
  geom_point(mapping = aes(prec, total_time, color = algorithm, shape = algorithm), size = dotSize) +
  scale_y_continuous(trans = "log10") +
  xlab("User-specified digits of precision") + 
  ylab("Time (ms)") + facet_wrap(vars(id), scales = "free")+
  theme_bw()+ 
  theme(aspect.ratio = 1,
        legend.position='bottom') #, legend.margin=margin(0,0,0,0), legend.box.margin=margin(-10,-10,-10,-10))
print(FinalTimeComparisons)
PrintPDF(FinalTimeComparisons, "FinalTimeComparisons.pdf")



RegionsComparisons <- ggplot(data = filter(temp, (algorithm == 'PAGANI' | algorithm == 'two-phase cuhre' | algorithm == 'cuhre') & 
                                             (id == '8D f7' | id == '5D f4' | id == '6D f6'))) + 
  geom_line(mapping = aes(prec, regions, color = algorithm)) +
  geom_point(mapping = aes(prec, regions, color = algorithm, shape = algorithm), size = dotSize) +
  scale_y_continuous(trans = "log10") +
  xlab("User-specified digits of precision") + 
  ylab("Regions") + facet_wrap(vars(id), scales = "free")+
  theme_bw()+ 
  theme(aspect.ratio = 1,
        legend.position='bottom') #, legend.margin=margin(0,0,0,0), legend.box.margin=margin(-10,-10,-10,-10))
print(RegionsComparisons)
PrintPDF(RegionsComparisons, "RegionsComparisons.pdf")

twoPhase    <- read_csv(file = "twoPhase")
BFC <- read_csv(file = "BFC")
dc        <- read_csv(file = "seqCuhre") 
dc <- mutate(dc, fregions = 0, lastPhase = 0)

BFC    <- convert_to_cuhre_format(filter(BFC), "PAGANI")
twoPhase <- convert_to_cuhre_format(filter(twoPhase), "two-phase cuhre")
dc      <- convert_to_cuhre_format(filter(dc), "cuhre")

temp <- rbind(
  select(BFC, id, prec, hw, error, relative_error, epsrel, total_time, regions, fregions, lastPhase, estimate, errorest, status),
  select(twoPhase, id, prec, hw, error, relative_error, epsrel, total_time, regions, fregions, lastPhase, estimate, errorest, status),
  select(dc, id, prec, hw, error, relative_error, epsrel, total_time, regions, fregions, lastPhase, estimate, errorest, status))

temp <- mutate(temp, algorithm=hw)
temp <- mutate(temp, filtering=hw)
ids <- unique(temp$id)

speedupOverTwo <- groupPlotSpeedup(filter(temp, algorithm == 'two-phase cuhre' & 
                                            (id == "8D f7" | id == "6D f6" | id == "5D f5")), filter(temp, algorithm == 'PAGANI') , ids, "two-phase")
speedupOverDC <- groupPlotSpeedup(filter(temp, algorithm == "cuhre" & 
                                           (id == "8D f7" | id == "6D f6" | id == "5D f5")), filter(temp, algorithm == 'PAGANI') , ids, "cuhre")
speedupdf <- rbind(speedupOverDC, speedupOverTwo)

speedupTwoFigs <- plotSpeedup(speedupdf)
#speedupTwoFigs <- plot_grid(speedupCombined, legend, ncol = 1, rel_heights = c(1, .05))
PrintPDF(speedupTwoFigs, "speedupCombined.pdf")
#speedupTwoFigs

