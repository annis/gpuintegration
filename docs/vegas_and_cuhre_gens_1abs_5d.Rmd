---
title: "Comparing VEGAS and CUHRE on Genz 1 (absolute value) in 5D"
author: "Marc Paterno"
date: "6/24/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

## Purpose of this document

This document shows a comparison of the speed of the VEGAS and CUHRE algorithms,
as implemented in the CUBA (http://www.feynarts.de/cuba/) library, and wrapped
by `cubacpp` (https://bitbucket.org/mpaterno/cubacpp).

## The algorithms

`vegas` is the Vegas algorithm of Lepage, as implemented in the CUBA library.
This version uses quasi-random (low-descrepency sequence) numbers, rather than pseudo-random numbers.
`cuhre_0` is the serial CUHRE algorithm, as implemented in the CUBA library, using `flag` = 0.
This version uses all the volumes produced by the algorithm for determining the final result.
`cuhre_1` is the serial CUHRE algorithm, as implemented in the CUBA library, using `flag` = 4.
This version uses only the final set of volumes produced by the algorithm for determining the final result.

For this analysis, the `cuhre_1` algorithm did not converge even for the largest fractional
error tolerance.

## The integrand

The integrand chosen is:
$$ | \cos(4 v +5 w + 6 x +7 y + 8 z)/k |$$
with $k = 0.6371054$. For this integrand, the normalization is approximate (meaning that the true value of the integrand is close to,
but not exactly, 1.0).

## Testing environment

These tests were run on a MacBook Pro laptop.

```{r child = 'mac130389-description.Rmd'}
```

## Description of the dataframe

```{r child = 'dataframe-description.Rmd'}
```

```{r read_data, echo = FALSE, message = FALSE}
d <- read_tsv("genz_1abs_5d_vegas_cuhre.out") %>%
  mutate(r = errorest/(epsrel*value)) %>%
  arrange(desc(epsrel), alg)

knitr::kable(d, digits = 16)
```

As a measure of the innate "efficiency" of each algorithm,
we consider how many function evaluations are required
to obtain a given fractional error tolerance.

```{r, echo = FALSE}
ggplot(d, aes(1/epsrel, neval, color = alg)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  labs(x = "Inverse of fractional error tolerance", y = "Number of function evaluations required")
```

## Analysis

For this integrand, the CUHRE algorithm requires far fewer function evaluations than VEGAS
to achieve a given relative error tolerance.
Except for low accuracies the `cuhre_0` algorithm requires fewer function evaluations than `cuhre_1`.

### Time and function evaluations

Does the *number* of function evaluations make a good proxy for the *time* spent in integrating?
For this integral, it seems to be a poor proxy for `cuhre_0` and a good proxy for `vegas`.

```{r, echo = FALSE, message = FALSE}
ggplot(d, aes(neval, time)) +
  geom_smooth(method = "lm") +
  geom_point() +
  facet_wrap(vars(alg), scales = "free", ncol = 1)
```

## Error estimate and function evaluations


```{r echo = FALSE, message = FALSE}
d %>%
ggplot(aes(neval, errorest, color = alg)) +
  geom_smooth(method = "lm") +
  geom_point() +
  scale_x_log10() +
  scale_y_log10()
```



